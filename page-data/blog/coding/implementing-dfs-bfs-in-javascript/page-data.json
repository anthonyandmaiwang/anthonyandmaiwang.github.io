{"componentChunkName":"component---src-templates-page-js","path":"/blog/coding/implementing-dfs-bfs-in-javascript/","result":{"data":{"page":{"name":"Implementing DFS/BFS in Javascript","menu":null,"childMarkdownRemark":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Traversing through complex data structures such as trees and graphs can be a challenging task, but it is a crucial element in many computer science problems. Two popular search algorithms that are commonly used for this purpose are depth-first search (DFS) and breadth-first search (BFS). In this blog post, we will delve into the basics of these algorithms and explore how they can be implemented in Javascript."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"BFS"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Breadth-first search (BFS) is a fundamental algorithm used in computer science to explore graphs or trees. It is a method for traversing a graph or tree data structure that explores all the vertices at the same level before moving on to the next level. BFS is particularly useful for finding the shortest path between two nodes in an unweighted graph or tree."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The BFS algorithm starts at the root node (or any other starting node) and explores all the neighboring nodes at the current level before moving on to the next level. It maintains a queue of nodes that have been visited but not yet explored. At each level, BFS dequeues the nodes in the queue and explores their neighboring nodes. If a node has not been visited before, it is added to the queue. The algorithm continues until all nodes have been visited."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"BFS is implemented using a queue data structure. The first node is added to the queue, and its neighboring nodes are added to the queue as well. The first node is then dequeued, and its neighbors are visited. If a neighbor has not been visited, it is added to the queue. This process continues until the queue is empty."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"One of the advantages of BFS is that it guarantees the shortest path to the destination node in an unweighted graph or tree. This is because BFS explores all the neighboring nodes at the same level before moving on to the next level. Additionally, BFS has a time complexity of O(V+E), where V is the number of vertices and E is the number of edges in the graph or tree. This makes it a relatively fast algorithm for exploring graphs and trees."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"In conclusion, BFS is particularly useful for finding the shortest path between two nodes in an unweighted graph or tree. BFS is implemented using a queue data structure and guarantees the shortest path to the destination node in an unweighted graph or tree. It is a fast algorithm with a time complexity of O(V+E)."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"\n\nfunction bfs(graph, start) {\n\n\n  const queue = [start];\n\n\n  const visited = new Set(queue);\n\n\n  while (queue.length > 0) {\n\n\n    const node = queue.shift();\n\n\n    const neighbors = graph[node];\n\n\n    for (const neighbor of neighbors) {\n\n\n      if (!visited.has(neighbor)) {\n\n\n        queue.push(neighbor);\n\n\n        visited.add(neighbor);\n\n\n      }\n\n\n    }\n\n\n  }\n\n\n}\n\n\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Here’s an example of how to use the code."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"\n\nconst graph = {\n\n\n  A: ['B', 'C'],\n\n\n  B: ['A', 'D'],\n\n\n  C: ['A', 'E'],\n\n\n  D: ['B', 'E', 'F'],\n\n\n  E: ['C', 'D', 'F'],\n\n\n  F: ['D', 'E'],\n\n\n};\n\n\nbfs(graph, 'A');\n\n\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"DFS"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Depth First Search (DFS) is a widely used algorithm for searching and traversing graphs or trees. The DFS algorithm starts at a given node, and explores as far as possible along each branch before backtracking. The algorithm works by maintaining a stack, where it stores the unexplored nodes. It is a fast algorithm with a time complexity of O(V+E)."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"\n\nfunction dfs(start) {\n\n\n    let stack = [start];\n\n\n    let visited = new Set();\n\n\n    while (stack.length > 0) {\n\n\n      let node = stack.pop();\n\n\n      if (!visited.has(node)) {\n\n\n        visited.add(node);\n\n\n        for (let neighbor of node.adjacent) {\n\n\n          stack.push(neighbor);\n\n\n        }\n\n\n      }\n\n\n    }\n\n\n}\n\n\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Here’s an example of how to use the code."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"\n\nconst graph = {\n\n\n  A: ['B', 'C'],\n\n\n  B: ['A', 'D'],\n\n\n  C: ['A', 'E'],\n\n\n  D: ['B', 'E', 'F'],\n\n\n  E: ['C', 'D', 'F'],\n\n\n  F: ['D', 'E'],\n\n\n};\n\n\ndfs(graph, 'A');\n\n\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Applications of BFS/DFS Algorithm"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"BFS/DFS algorithm is useful for various applications such as finding the path between two nodes, detecting cycles in a graph, finding connected components in a graph, and many more. It is also used as a building block for other algorithms such as topological sorting, strongly connected components, and minimum spanning tree algorithms."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"BFS can be used to solve a variety of problems. It can be used to find the shortest path between two nodes in an unweighted graph or tree. It can also be used to find all the nodes that are reachable from a given node. Additionally, BFS can be used to check if a graph or tree is bipartite (i.e., it can be divided into two sets such that every edge connects a node in one set to a node in the other set)."}]}],"data":{"quirksMode":false}}},"description":null,"affiliate":true,"modifiedTime":"2023-03-21T21:46:22.829Z","cover":null,"showTitle":true},"allGooglePhotosPhoto":{"nodes":[]}},"pageContext":{"index":false,"page":true,"name":"Implementing DFS/BFS in Javascript","slug":"/blog/coding/implementing-dfs-bfs-in-javascript","id":"/blog/coding/implementing-dfs-bfs-in-javascript","albumTitle":"Implementing DFS/BFS in Javascript"}},"staticQueryHashes":["2515861143"],"slicesMap":{}}