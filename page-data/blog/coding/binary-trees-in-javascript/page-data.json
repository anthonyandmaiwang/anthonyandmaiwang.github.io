{"componentChunkName":"component---src-templates-page-js","path":"/blog/coding/binary-trees-in-javascript/","result":{"data":{"page":{"name":"Binary Trees In Javascript","menu":null,"childMarkdownRemark":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Binary trees are one of the fundamental data structures in computer science. They are used to represent hierarchical structures and have many applications, including in computer science, mathematics, and biology. In this blog post, we will explore what binary trees are, how they are structured, and some of their applications."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"What is a Binary Tree?"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"A binary tree is a tree data structure in which each node has at most two children, referred to as the left child and the right child. A node that has no children is called a leaf node or a terminal node. A node that has children is called an internal node."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The topmost node of the tree is called the root node. Every node in the tree, except for the root node, has exactly one parent node. The binary tree is recursive in nature, meaning that each subtree of a binary tree is itself a binary tree."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Binary Tree Structure"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The structure of a binary tree is defined by its nodes and their connections. A binary tree can be empty, in which case it contains no nodes. Otherwise, a binary tree consists of a root node and two subtrees, one of which is the left subtree and the other of which is the right subtree."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Each node in a binary tree contains a value or a data element, and a reference to its left and right child nodes. The left child node contains values that are less than the parent node's value, and the right child node contains values that are greater than the parent node's value. This property is known as the binary search tree property, and it allows for efficient searching of values within the tree."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Traversal of Binary Trees"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"There are three common methods for traversing a binary tree: inorder, preorder, and postorder. Inorder traversal visits the left subtree, the current node, and then the right subtree. Preorder traversal visits the current node, the left subtree, and then the right subtree. Postorder traversal visits the left subtree, the right subtree, and then the current node."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Implementation"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"\n\nclass Node {\n\n\n  constructor(data) {\n\n\n    this.data = data;\n\n\n    this.left = null;\n\n\n    this.right = null;\n\n\n  }\n\n\n}\n\n\nclass BinaryTree {\n\n\n  constructor() {\n\n\n    this.root = null;\n\n\n  }\n\n\n  insertHelper(current, newNode) {\n\n\n    if (newNode.data < current.data) {\n\n\n      if (current.left === null) {\n\n\n        current.left = newNode;\n\n\n      } else {\n\n\n        this.insertHelper(current.left, newNode);\n\n\n      }\n\n\n    } else {\n\n\n      if (current.right === null) {\n\n\n        current.right = newNode;\n\n\n      } else {\n\n\n        this.insertHelper(current.right, newNode);\n\n\n      }\n\n\n    }\n\n\n  }\n\n\n  insert(data) {\n\n\n    const newNode = new Node(data);\n\n\n    if (this.root === null) {\n\n\n      this.root = newNode;\n\n\n    } else {\n\n\n      this.insertHelper(this.root, newNode);\n\n\n    }\n\n\n  }\n\n\n  inorderHelper(node, fn) {\n\n\n    if (node !== null) {\n\n\n      this.inorderHelper(node.left, fn);\n\n\n      fn(node);\n\n\n      this.inorderHelper(node.right, fn);\n\n\n    }\n\n\n  }\n\n\n  inorder(fn) {\n\n\n    this.inorderHelper(this.root, fn);\n\n\n  }\n\n\n}\n\n\nconst tree = new BinaryTree();\n\n\ntree.insert(5);\n\n\ntree.insert(3);\n\n\ntree.insert(7);\n\n\ntree.insert(2);\n\n\ntree.insert(4);\n\n\ntree.insert(6);\n\n\ntree.insert(8);\n\n\ntree.inorder((node) => console.log(node.data)); \n\n\n// prints \"2 3 4 5 6 7 8\"\n\n\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Applications of Binary Trees"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Binary trees have many applications in computer science. One common application is in searching and sorting algorithms. Binary search trees can be used to efficiently search for a value in a sorted list. Binary heaps are another type of binary tree that is used to implement priority queues."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Binary trees are also used in data compression algorithms, such as Huffman coding, which is used in JPEG and MP3 file compression. Huffman coding uses a binary tree to encode data using variable-length codes."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"In addition to computer science, binary trees are also used in mathematics and biology. In mathematics, binary trees are used to represent the structure of decision trees, which are used in game theory and artificial intelligence. In biology, binary trees are used to represent phylogenetic trees, which show the evolutionary relationships between different species."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Binary Search Trees"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Binary search trees (BSTs) are a data structure commonly used in computer science for efficient searching, sorting, and insertion operations. They are a type of binary tree in which each node has at most two children and each node's left child contains a value less than the node's value, while each node's right child contains a value greater than the node's value."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"BSTs are commonly used to implement dynamic sets or dictionaries, where elements can be inserted, deleted, and searched for in logarithmic time on average."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"Insertion"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"To insert a new element into a BST, we first start at the root node. If the tree is empty, we simply create a new node with the value we want to insert and make it the root node. Otherwise, we compare the value we want to insert with the value of the current node. If the value is less than the current node's value, we move to its left child and repeat the process. If the value is greater than the current node's value, we move to its right child and repeat the process. We continue doing this until we reach a leaf node with no children, at which point we create a new node with the value we want to insert and make it the child of the leaf node."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"Searching"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"To search for an element in a BST, we start at the root node and compare the value we are searching for with the value of the current node. If the value is equal to the current node's value, we have found the element and can return it. If the value is less than the current node's value, we move to its left child and repeat the process. If the value is greater than the current node's value, we move to its right child and repeat the process. We continue doing this until we either find the element or reach a leaf node with no children, at which point we know the element is not in the tree."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"Implementation Details"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"\n\nclass BinarySearchTree {\n\n\n  constructor() {\n\n\n    this.root = null;\n\n\n  }\n\n\n  // Helper function to insert a node recursively\n\n\n  insertHelper(current, value) {\n\n\n    if (value < current.value) {\n\n\n      if (current.left === null) {\n\n\n        current.left = new Node(value);\n\n\n      } else {\n\n\n        this.insertHelper(current.left, value);\n\n\n      }\n\n\n    } else {\n\n\n      if (current.right === null) {\n\n\n        current.right = new Node(value);\n\n\n      } else {\n\n\n        this.insertHelper(current.right, value);\n\n\n      }\n\n\n    }\n\n\n  }\n\n\n  // Insert a node into the tree\n\n\n  insert(value) {\n\n\n    if (this.root === null) {\n\n\n      this.root = new Node(value);\n\n\n    } else {\n\n\n      this.insertHelper(this.root, value);\n\n\n    }\n\n\n  }\n\n\n  // Helper function to search for a node recursively\n\n\n  searchHelper(current, value) {\n\n\n    if (current === null) {\n\n\n      return false;\n\n\n    } else if (current.value === value) {\n\n\n      return true;\n\n\n    } else if (value < current.value) {\n\n\n      return this.searchHelper(current.left, value);\n\n\n    } else {\n\n\n      return this.searchHelper(current.right, value);\n\n\n    }\n\n\n  }\n\n\n  // Search for a node in the tree\n\n\n  search(value) {\n\n\n    return this.searchHelper(this.root, value);\n\n\n  }\n\n\n}\n\n\n// Example usage:\n\n\nconst tree = new BinarySearchTree();\n\n\ntree.insert(5);\n\n\ntree.insert(3);\n\n\ntree.insert(7);\n\n\nconsole.log(tree.search(3)); // prints \"true\"\n\n\nconsole.log(tree.search(6)); // prints \"false\"\n\n\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"Complexity"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The time complexity of search, insertion, and deletion operations in a BST is O(log n) on average, where n is the number of nodes in the tree. However, in the worst case (i.e., when the tree is highly unbalanced), the time complexity can be O(n), which is the same as a linked list."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Conclusion"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"In conclusion, binary trees are a fundamental data structure that is used in many applications in computer science, mathematics, and biology. Their simple structure allows for efficient searching and sorting algorithms, as well as data compression techniques. They are also used to represent decision trees and phylogenetic trees, making them a versatile tool in many fields."}]}],"data":{"quirksMode":false}}},"description":null,"affiliate":true,"modifiedTime":"2023-03-22T05:59:02.021Z","cover":null,"showTitle":true}},"pageContext":{"index":false,"page":true,"slug":"/blog/coding/binary-trees-in-javascript","id":"/blog/coding/binary-trees-in-javascript"}},"staticQueryHashes":["2515861143"],"slicesMap":{}}