{"componentChunkName":"component---src-templates-page-js","path":"/blog/coding/djikstras-algorithm/","result":{"data":{"page":{"name":"Djikstra's Algorithm","menu":null,"childMarkdownRemark":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Dijkstra's algorithm is a popular algorithm used to solve the shortest path problem in graph theory. The algorithm, named after its inventor, Dutch computer scientist Edsger W. Dijkstra, is used to find the shortest path between two nodes in a weighted graph."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The problem of finding the shortest path in a graph arises in many real-world applications, such as routing in computer networks, scheduling in job shops, and transportation planning. Dijkstra's algorithm is particularly useful in these applications because it is efficient and guarantees that the shortest path will be found."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"To understand Dijkstra's algorithm, it is important to first understand the concept of a weighted graph. A weighted graph is a graph in which each edge has a weight associated with it. This weight can represent, for example, the distance between two cities or the cost of a flight between two airports."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Dijkstra's algorithm works by maintaining a set of unvisited nodes and their tentative distances from the starting node. Initially, the distance of the starting node from itself is set to zero, and the distances of all other nodes are set to infinity. The algorithm then selects the node with the smallest tentative distance and marks it as visited. The algorithm then updates the tentative distances of all the unvisited neighbors of the selected node."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"This process is repeated until the destination node is reached or all nodes have been visited. At the end of the algorithm, the shortest path from the starting node to the destination node is the path that follows the edges with the smallest weights from the starting node to the destination node."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Dijkstra's algorithm can be implemented using a priority queue to store the unvisited nodes and their tentative distances. In each iteration of the algorithm, the node with the smallest tentative distance is extracted from the priority queue, and its neighbors are updated if necessary."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"One important aspect of Dijkstra's algorithm is that it does not work with negative edge weights. This is because if there is a negative edge weight, the algorithm may end up revisiting nodes in a cycle, resulting in an infinite loop. To handle graphs with negative edge weights, the Bellman-Ford algorithm can be used instead."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Implementation Details"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"\n\nfunction dijkstra(graph, startNode, endNode) {\n\n\n  const distances = {};\n\n\n  const visited = {};\n\n\n  const previousNodes = {};\n\n\n  const queue = new PriorityQueue();\n\n\n  // initialize distances to infinity for all nodes except the start node, which is set to 0\n\n\n  for (let node in graph) {\n\n\n    distances[node] = Infinity;\n\n\n  }\n\n\n  distances[startNode] = 0;\n\n\n  // add the start node to the priority queue\n\n\n  queue.enqueue(startNode, 0);\n\n\n  while (!queue.isEmpty()) {\n\n\n    // get the node with the smallest distance from the start node\n\n\n    const currentNode = queue.dequeue().element;\n\n\n    // mark the current node as visited\n\n\n    visited[currentNode] = true;\n\n\n    // stop searching if the end node has been reached\n\n\n    if (currentNode === endNode) {\n\n\n      break;\n\n\n    }\n\n\n    // update the distances of the neighboring nodes\n\n\n    for (let neighbor in graph[currentNode]) {\n\n\n      const distance = graph[currentNode][neighbor];\n\n\n      const totalDistance = distance + distances[currentNode];\n\n\n      if (!visited[neighbor] && totalDistance < distances[neighbor]) {\n\n\n        distances[neighbor] = totalDistance;\n\n\n        previousNodes[neighbor] = currentNode;\n\n\n        queue.enqueue(neighbor, totalDistance);\n\n\n      }\n\n\n    }\n\n\n  }\n\n\n  // build the path from the start node to the end node\n\n\n  const path = [endNode];\n\n\n  let node = endNode;\n\n\n  while (node !== startNode) {\n\n\n    node = previousNodes[node];\n\n\n    path.unshift(node);\n\n\n  }\n\n\n  return {\n\n\n    path,\n\n\n    distance: distances[endNode]\n\n\n  };\n\n\n}\n\n\n// example usage\n\n\nconst graph = {\n\n\n  a: { b: 5, c: 2 },\n\n\n  b: { d: 4, e: 2 },\n\n\n  c: { b: 8, e: 7 },\n\n\n  d: { e: 6, f: 3 },\n\n\n  e: { f: 1 },\n\n\n  f: {}\n\n\n};\n\n\nconst result = dijkstra(graph, 'a', 'f');\n\n\nconsole.log(result.path); // output: [ 'a', 'c', 'e', 'f' ]\n\n\nconsole.log(result.distance); // output: 8\n\n\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"In this implementation, graph is an object representing the weighted graph, where each key is a node and each value is another object containing the neighboring nodes and their distances. The startNode and endNode arguments specify the starting and ending nodes of the path to be found."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The dijkstra function first initializes the distances to all nodes as Infinity except for the start node, which is set to 0. It then uses a priority queue to keep track of the unvisited nodes and their tentative distances from the start node."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"In each iteration of the main loop, the function extracts the node with the smallest tentative distance from the priority queue, marks it as visited, and updates the tentative distances of its neighboring nodes. The function stops searching when the end node is reached or when there are no more unvisited nodes."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"After the main loop completes, the function builds the path from the start node to the end node by tracing back through the previousNodes object. The path and distance properties of the returned object contain the shortest path and its distance, respectively."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Conclusion"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Dijkstra's algorithm is a powerful tool for finding the shortest path in a weighted graph. It is easy to understand and implement, and it guarantees that the shortest path will be found. However, it is important to keep in mind its limitations with respect to negative edge weights."}]}],"data":{"quirksMode":false}}},"description":null,"affiliate":true,"modifiedTime":"2023-03-25T21:10:52.410Z","cover":null,"showTitle":true},"allGooglePhotosPhoto":{"nodes":[]}},"pageContext":{"index":false,"page":true,"name":"Djikstra's Algorithm","slug":"/blog/coding/djikstras-algorithm","id":"/blog/coding/djikstras-algorithm","albumTitle":"Djikstra's Algorithm"}},"staticQueryHashes":["2515861143"],"slicesMap":{}}