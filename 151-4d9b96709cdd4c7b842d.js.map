{"version":3,"file":"151-4d9b96709cdd4c7b842d.js","mappings":"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","sources":["webpack://wedding/./src/hooks/IsInViewport.js","webpack://wedding/./src/hooks/useIsClient.js","webpack://wedding/./src/layout/components/Countdown/index.js"],"sourcesContent":["import { useState, useEffect } from \"react\";\n\n// Hook\nexport function useOnScreen(ref) {\n  // State and setter for storing whether element is visible\n  const [isIntersecting, setIntersecting] = useState(false);\n\n  useEffect(() => {\n    let copiedRef = ref;\n\n    const observer = new IntersectionObserver(\n      ([entry]) => {\n        // Update our state when observer callback fires\n        setIntersecting(entry.isIntersecting);\n      },\n      {\n        rootMargin: '0px',\n      }\n    );\n    if (ref.current) {\n      observer.observe(ref.current);\n    }\n    return () => {\n      if (observer.unobserve && copiedRef.current) {\n        observer.unobserve(copiedRef.current);\n      }\n    };\n  }, [ref]); // Empty array ensures that effect is only run on mount and unmount\n\n  return isIntersecting;\n}\n","import { useState, useEffect } from \"react\";\n\nconst useIsClient = () => {\n  const [isClient, setClient] = useState(false);\n  const key = isClient ? \"client\" : \"server\";\n\n  useEffect(() => {\n    setClient(true);\n  }, []);\n\n  return { isClient, key };\n};\n\nexport default useIsClient;","import * as React from \"react\";\nimport {useOnScreen} from \"../../../hooks/IsInViewport\";\nimport useIsClient from \"../../../hooks/useIsClient\";\nimport {H1} from \"../Header\";\nimport CenteredText from \"../CenteredText\";\n\nimport moment from \"moment\";\n\nimport \"./styles.scss\";\n\nconst AnimatedCard = ({ animation, digit }) => {\n    return (\n        <div className={`flipCard ${animation}`}>\n            <span>{digit}</span>\n        </div>\n    );\n};\n\nconst StaticCard = ({ position, digit }) => {\n    return (\n        <div className={position}>\n            <span>{digit}</span>\n        </div>\n    );\n};\n\nconst FlipUnitContainer = ({ digit, shuffle, unit }) => {\n    let currentDigit = digit;\n    let previousDigit = digit + 1;\n\n    if (unit === 'seconds' || unit === 'minutes') {\n        currentDigit = parseInt(currentDigit) === 0\n            ? 60\n            : currentDigit;\n    } else if (unit === 'hours') {\n        currentDigit = parseInt(currentDigit) === 0\n            ? 24\n            : currentDigit;\n    }\n\n    // add zero\n    if (currentDigit < 10) {\n        currentDigit = `0${currentDigit}`;\n    }\n    if (previousDigit < 10) {\n        previousDigit = `0${previousDigit}`;\n    }\n\n    // shuffle digits\n    const digit1 = shuffle\n        ? previousDigit\n        : currentDigit;\n    const digit2 = !shuffle\n        ? previousDigit\n        : currentDigit;\n\n    // shuffle animations\n    const animation1 = shuffle\n        ? 'fold'\n        : 'unfold';\n    const animation2 = !shuffle\n        ? 'fold'\n        : 'unfold';\n\n    return (\n        <div>\n            <div className=\"FlipCardUnitLabel\">{unit.charAt(0).toUpperCase() + unit.slice(1)}</div>\n            <div className={'flipUnitContainer'}>\n                <StaticCard\n                    position={'upperCard'}\n                    digit={currentDigit}\n                />\n                <StaticCard\n                    position={'lowerCard'}\n                    digit={previousDigit}\n                />\n                <AnimatedCard\n                    digit={digit1}\n                    animation={animation1}\n                />\n                <AnimatedCard\n                    digit={digit2}\n                    animation={animation2}\n                />\n            </div>\n        </div>\n    );\n};\n\nconst Countdown = (props) => {\n    const ref = React.useRef();\n    const onScreen = useOnScreen(ref);\n\n    const [time, setTime] = React.useState({\n        days: {\n            value: 0,\n            shouldShuffle: true,\n        },\n        hours: {\n            value: 0,\n            shouldShuffle: true,\n        },\n        minutes: {\n            value: 0,\n            shouldShuffle: true,\n        },\n        seconds: {\n            value: 0,\n            shouldShuffle: true,\n        }\n    });\n\n    const eta = moment.unix(parseInt(props.eta));\n\n    React.useEffect(() => {\n        const interval = setInterval(() => {\n            if (onScreen) {\n                const delta = moment.duration(eta.diff(moment.now()));\n\n                const timePortion = ['days', 'hours', 'minutes', 'seconds'];\n                let parts = [];\n                for (const part of timePortion) {\n                    let d = 0;\n                    switch(part) {\n                        case 'days':\n                            d = delta.asDays();\n                            break;\n                        case 'hours':\n                            d = delta.asHours();\n                            break;\n                        case 'minutes':\n                            d = delta.asMinutes();\n                            break;\n                        case 'seconds':\n                            d = delta.asSeconds();\n                            break;\n                        default:\n                            break;\n                    }\n                \n                delta.subtract(moment.duration(Math.floor(d), part));\n                parts.push(Math.floor(d));\n                }\n\n                const nextTime = parts.reduce((accum, value, idx) => {\n                    const timeUnit = timePortion[idx];\n                    const shouldShuffle = time[timeUnit].value !== value ;\n                    return {\n                        ...accum,\n                        [timeUnit]: {\n                            value: value,\n                            shouldShuffle\n                        }\n                    };\n                }, {});\n\n                setTime(nextTime);\n            }\n        }, 30);\n\n        return () => clearInterval(interval);\n    }, [onScreen, time, eta, setTime]);\n\n\n    if (eta <= moment.now()) {\n        return (\n            <CenteredText>\n                <H1>It's Wedding Day!</H1>\n            </CenteredText>\n        );\n    }\n\n    return (\n        <div ref={ref} className={'FlipClock'}>\n            {Object.keys(time).map(key => {\n                const {value, shouldShuffle} = time[key];\n                return (\n                    <FlipUnitContainer\n                        key={key}\n                        unit={key}\n                        digit={value}\n                        shuffle={shouldShuffle}\n                    />\n                );\n            })}\n        </div>\n    );\n}\n\n\nconst CountdownRenderer = (props) => {\n    const {isClient} = useIsClient();\n\n    if (!isClient) {\n        return <div className=\"SuspenseCountdown\"></div>; \n    }\n    return <Countdown {...props} />\n}\n\nexport default CountdownRenderer;"],"names":["useOnScreen","ref","isIntersecting","setIntersecting","useState","useEffect","copiedRef","observer","IntersectionObserver","_ref","entry","rootMargin","current","observe","unobserve","useIsClient","isClient","setClient","key","AnimatedCard","animation","digit","React","className","StaticCard","_ref2","position","FlipUnitContainer","_ref3","shuffle","unit","currentDigit","previousDigit","parseInt","digit1","digit2","animation1","animation2","charAt","toUpperCase","slice","Countdown","props","onScreen","time","setTime","days","value","shouldShuffle","hours","minutes","seconds","eta","moment","interval","setInterval","delta","diff","timePortion","parts","part","d","asDays","asHours","asMinutes","asSeconds","subtract","Math","floor","push","nextTime","reduce","accum","idx","timeUnit","clearInterval","CenteredText","H1","Object","keys","map"],"sourceRoot":""}