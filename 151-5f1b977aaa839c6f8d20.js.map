{"version":3,"file":"151-5f1b977aaa839c6f8d20.js","mappings":"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","sources":["webpack://wedding/./src/hooks/IsInViewport.js","webpack://wedding/./src/hooks/useIsClient.js","webpack://wedding/./src/layout/components/Countdown/index.js"],"sourcesContent":["import { useState, useEffect } from \"react\";\n\n// Hook\nexport function useOnScreen(ref) {\n  // State and setter for storing whether element is visible\n  const [isIntersecting, setIntersecting] = useState(false);\n\n  useEffect(() => {\n    let copiedRef = ref;\n\n    const observer = new IntersectionObserver(\n      ([entry]) => {\n        // Update our state when observer callback fires\n        setIntersecting(entry.isIntersecting);\n      },\n      {\n        rootMargin: '0px',\n      }\n    );\n    if (ref.current) {\n      observer.observe(ref.current);\n    }\n    return () => {\n      if (observer.unobserve && copiedRef.current) {\n        observer.unobserve(copiedRef.current);\n      }\n    };\n  }, [ref]); // Empty array ensures that effect is only run on mount and unmount\n\n  return isIntersecting;\n}\n","import { useState, useEffect } from \"react\";\n\nconst useIsClient = () => {\n  const [isClient, setClient] = useState(false);\n  const key = isClient ? \"client\" : \"server\";\n\n  useEffect(() => {\n    setClient(true);\n  }, []);\n\n  return { isClient, key };\n};\n\nexport default useIsClient;","import * as React from \"react\";\nimport {useOnScreen} from \"../../../hooks/IsInViewport\";\nimport useIsClient from \"../../../hooks/useIsClient\";\n\nimport moment from \"moment\";\n\nimport \"./styles.scss\";\n\nconst AnimatedCard = ({ animation, digit }) => {\n    return (\n        <div className={`flipCard ${animation}`}>\n            <span>{digit}</span>\n        </div>\n    );\n};\n\nconst StaticCard = ({ position, digit }) => {\n    return (\n        <div className={position}>\n            <span>{digit}</span>\n        </div>\n    );\n};\n\nconst FlipUnitContainer = ({ digit, shuffle, unit }) => {\n    let currentDigit = digit;\n    let previousDigit = digit + 1;\n\n    if (unit === 'seconds' || unit === 'minutes') {\n        currentDigit = parseInt(currentDigit) === 0\n            ? 60\n            : currentDigit;\n    } else if (unit === 'hours') {\n        currentDigit = parseInt(currentDigit) === 0\n            ? 24\n            : currentDigit;\n    }\n\n    // add zero\n    if (currentDigit < 10) {\n        currentDigit = `0${currentDigit}`;\n    }\n    if (previousDigit < 10) {\n        previousDigit = `0${previousDigit}`;\n    }\n\n    // shuffle digits\n    const digit1 = shuffle\n        ? previousDigit\n        : currentDigit;\n    const digit2 = !shuffle\n        ? previousDigit\n        : currentDigit;\n\n    // shuffle animations\n    const animation1 = shuffle\n        ? 'fold'\n        : 'unfold';\n    const animation2 = !shuffle\n        ? 'fold'\n        : 'unfold';\n\n    return (\n        <div>\n            <div>{unit.charAt(0).toUpperCase() + unit.slice(1)}</div>\n            <div className={'flipUnitContainer'}>\n                <StaticCard\n                    position={'upperCard'}\n                    digit={currentDigit}\n                />\n                <StaticCard\n                    position={'lowerCard'}\n                    digit={previousDigit}\n                />\n                <AnimatedCard\n                    digit={digit1}\n                    animation={animation1}\n                />\n                <AnimatedCard\n                    digit={digit2}\n                    animation={animation2}\n                />\n            </div>\n        </div>\n    );\n};\n\nconst Countdown = (props) => {\n    const ref = React.useRef();\n    const onScreen = useOnScreen(ref);\n\n    const [time, setTime] = React.useState({\n        days: {\n            value: 0,\n            shouldShuffle: true,\n        },\n        hours: {\n            value: 0,\n            shouldShuffle: true,\n        },\n        minutes: {\n            value: 0,\n            shouldShuffle: true,\n        },\n        seconds: {\n            value: 0,\n            shouldShuffle: true,\n        }\n    });\n\n    const eta = moment.unix(parseInt(props.eta));\n\n    React.useEffect(() => {\n        const interval = setInterval(() => {\n            if (onScreen) {\n                const delta = moment.duration(eta.diff(moment.now()));\n\n                const timePortion = ['days', 'hours', 'minutes', 'seconds'];\n                let parts = [];\n                for (const part of timePortion) {\n                    let d = 0;\n                    switch(part) {\n                        case 'days':\n                            d = delta.asDays();\n                            break;\n                        case 'hours':\n                            d = delta.asHours();\n                            break;\n                        case 'minutes':\n                            d = delta.asMinutes();\n                            break;\n                        case 'seconds':\n                            d = delta.asSeconds();\n                            break;\n                        default:\n                            break;\n                    }\n                \n                delta.subtract(moment.duration(Math.floor(d), part));\n                parts.push(Math.floor(d));\n                }\n\n                const nextTime = parts.reduce((accum, value, idx) => {\n                    const timeUnit = timePortion[idx];\n                    const shouldShuffle = time[timeUnit].value !== value ;\n                    return {\n                        ...accum,\n                        [timeUnit]: {\n                            value: value,\n                            shouldShuffle\n                        }\n                    };\n                }, {});\n\n                setTime(nextTime);\n            }\n        }, 30);\n\n        return () => clearInterval(interval);\n    }, [onScreen, time, eta, setTime]);\n\n\n    if (eta <= moment.now()) {\n        return (<>The event is over!</>);\n    }\n\n    return (\n        <div ref={ref} className={'FlipClock'}>\n            {Object.keys(time).map(key => {\n                const {value, shouldShuffle} = time[key];\n                return (\n                    <FlipUnitContainer\n                        key={key}\n                        unit={key}\n                        digit={value}\n                        shuffle={shouldShuffle}\n                    />\n                );\n            })}\n        </div>\n    );\n}\n\n\nconst CountdownRenderer = (props) => {\n    const {isClient} = useIsClient();\n\n    if (!isClient) {\n        return null; \n    }\n    return <Countdown {...props} />\n}\n\nexport default CountdownRenderer;"],"names":["useOnScreen","ref","isIntersecting","setIntersecting","useState","useEffect","copiedRef","observer","IntersectionObserver","entry","rootMargin","current","observe","unobserve","isClient","setClient","key","AnimatedCard","animation","digit","className","StaticCard","position","FlipUnitContainer","shuffle","unit","currentDigit","previousDigit","parseInt","digit1","digit2","animation1","animation2","charAt","toUpperCase","slice","Countdown","props","React","onScreen","time","setTime","days","value","shouldShuffle","hours","minutes","seconds","eta","moment","interval","setInterval","delta","diff","timePortion","parts","part","d","asDays","asHours","asMinutes","asSeconds","subtract","Math","floor","push","nextTime","reduce","accum","idx","timeUnit","clearInterval","Object","keys","map","useIsClient"],"sourceRoot":""}